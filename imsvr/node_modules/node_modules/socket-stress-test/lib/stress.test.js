'use strict'

var _ = require('underscore')
  , io = require('socket.io-client')
  , self

module.exports = exports = SocketPromiseHandler

/**
 * The SocketTester, holder of a socket client
 * @param {String} ioUrl     -- The IO URL where it needs to connect to
 * @param {Object} ioOptions -- Additional options
 */
function SocketTester(ioUrl, ioOptions) {
    this.socket = io(ioUrl, ioOptions).socket
}

/**
 * The Socket scheduler, that can attach events
 * @param {Object} options -- options for IO and such
 */
function SocketPromiseHandler(options) {

    var defaultCallback = function() {
        return true
    }

    this.newCallBack = defaultCallback
    this.connectionCallback = defaultCallback
    this.disconnectCallback = defaultCallback
    this.emitTasks = []
    this.options = _.extend({ 
                                ioUrl: null
                              , maxConnections: 100
                              , connectionInterval: 1000 // One second
                            }
                            , options)


    /**
     * Start the process of looping through connections
     */
    this.startProcess = function() {
        // create reference for in interval
        self = this
        self.currentConnections = 0

        self.socketIntervalId = setInterval(function() {
            self.currentConnections ++

            if (self.options.maxConnections < self.currentConnections) {
                clearInterval(self.socketIntervalId)
                return
            }
            var socketTester = new SocketTester(self.options.ioUrl, self.options.ioOptions)

            // add to all the socket tests
            self.attachCallbacks(socketTester.socket)
            self.fireEmitTasks(socketTester.socket)

            // call the new callback function
            self.newCallBack(socketTester, self.currentConnections)
        }, self.options.connectionInterval)
    }

    /**
     * Stops the process of creating new connections
     */
    this.stopProcess = function() {
        clearInterval(this.socketIntervalId)
    }

    /**
     * Attach regular events
     * @param  {Socket} socket -- the socket which we need to attach to
     */
    this.attachCallbacks = function(socket) {
        socket.on('connection', this.connectionCallback)
        socket.on('disconnect', this.disconnectCallback)
    }

    /**
     * Fire the emits on a certain sequence
     * @param  {Socket} socket -- The socket which need to be fired
     */
    this.fireEmitTasks = function(socket) {
        var currentDelay = 0
        self = this
        this.emitTasks.forEach(function(task){
            currentDelay += task.eventDelay
            self.fireEmit( socket 
                         , task
                         , currentDelay
                         )
        })
    }

    /**
     * Fire a emit to a socket
     * @param  {Socket} socket      -- The socket object
     * @param  {Object} eventObject -- Info about the event
     * @param  {Number} delay       -- The delay of firing
     */
    this.fireEmit = function(socket, eventObject, delay) {
        self = this
        setTimeout(function() {
            socket.emit(eventObject.eventKey, eventObject.eventPayload)
            if (self.emitTasks.indexOf(eventObject) == self.emitTasks.length - 1) {
                // call it again
                self.fireEmitTasks(socket)
            }
        }, delay)
    }

    /**
     * A convenient class to attach a callback whenever a new 
     * connection is opened.
     * @param  {Function} callback -- The new() callback
     * @return {SocketPromiseHandler}  
     */
    this.new = function(callback) {
        this.newCallBack = callback
        return this
    }

    /**
     * A chaining function to add new emits
     * @param {String} eventKey     -- The event key
     * @param {[type]} eventPayload -- The event payload
     */
    this.addEmit = function(eventKey, eventPayload, eventDelay) {
        eventDelay = eventDelay || 0
        this.emitTasks.push({
              eventKey: eventKey
            , eventPayload: eventPayload
            , eventDelay: eventDelay
        })
        return this
    }

    /**
     * For attaching to a a callback when there is a new connection
     * @param  {Function} callback
     * @return {SocketPromiseHandler}
     */
    this.connection = function(callback) {
        this.connectionCallback = callback
        return this
    }

    /**
     * A callback when a socket disconnects
     * @param  {Function} callback -- The callback that needs to be fired
     * @return {SocketPromiseHandler}
     */
    this.disconnect = function(callback) {
        this.disconnectCallback = callback
        return this
    }

    /**
     * Run the process
     */
    this.run = function() {
        this.startProcess()
    }

    /**
     * Stop the process
     */
    this.stop = function() {
        this.stopProcess()
    }
}
